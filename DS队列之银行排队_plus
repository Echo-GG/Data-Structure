#include <bits/stdc++.h>
using namespace std;

class Customer
{
private:
	char type;
	int time;
public:
	Customer(){}
	Customer(char c,int t):type(c),time(t){}
	char get_type()const{return type;}
	int get_time()const{return time;}
};
int main()
{
	int cntA = 0;
	int cntB = 0;
	int cntC = 0;
	int timeA = 0;
	int timeB = 0;
	int timeC = 0;
	int n;
	cin>>n;
	queue<Customer> Qa,Qb,Qc;
	vector<char>types;
	for(int i=0;i<n;i++)
	{
		char c;
		cin>>c;
		types.push_back(c);
	}
//	for(char c:types)
//	{
//		cout<<c<<" ";
//	}
//	cout<<endl;//debug1
	vector<int>times;
	for(int i=0;i<n;i++)
	{
		int t;
		cin>>t;
		times.push_back(t);
	}
//	for(int t:times)
//	{
//		cout<<t<<" ";
//	}
//	cout<<endl;//debug2

//comment1:vector(n) will reserve n empty (0) places at the front,
//so when using the v.push_back(),the front n places will remain 0,
//things will act like (e.g.n = 4) 0 0 0 0 1 2 3 4

	Customer* customers = new Customer[n];
	for(int i=0;i<n;i++)
	{
		customers[i] = Customer(types[i],times[i]);
	}
	for(int i=0;i<n;i++)
	{
		if(customers[i].get_type()=='A')
		{
			Qa.push(customers[i]);
			cntA++;
		}
		else if(customers[i].get_type()=='B')
		{
			Qb.push(customers[i]);
			cntB++;
		}
		else if(customers[i].get_type()=='C')
		{
			Qc.push(customers[i]);
			cntC++;
		}
	}
	while(!Qa.empty())
	{
		timeA+=Qa.front().get_time();
		Qa.pop();
	}
	while(!Qb.empty())
	{
		timeB+=Qb.front().get_time();
		Qb.pop();
	}
	while(!Qc.empty())
	{
		timeC+=Qc.front().get_time();
		Qc.pop();
	}
//	cout<<timeA<<" "<<cntA<<endl<<timeB<<" "<<cntB<<endl<<timeC<<" "<<cntC<<endl;//debug3
	cout<<timeA/cntA<<endl<<timeB/cntB<<endl<<timeC/cntC<<endl;
	delete[]customers;
	return 0;
}
